



/*
int ReadFileAndInsertInBlockList(char **buff){
	struct file *f;
	mm_segment_t fs;
	char *buf;
	// char *tempchar;
	int i;//,j;

	buf = kmalloc(sizeof(char *)*MaxList, GFP_KERNEL);	/* Max MaxList bytes !*/
	for(i=0;i<MaxList;i++)
		buf[i] = 0;
	f = filp_open(IpFile, O_RDONLY, 0);

	if(f == NULL){
		printk(KERN_ALERT "Ha Unable to open File.\n");
		return 0;
	}
	else{
		fs = get_fs(); /* Segment Descriptor. */
		set_fs(get_ds());
		f->f_op->read(f, buf, MaxList, &f->f_pos);
		set_fs(fs);
	}
	printk(KERN_INFO "starts with %s", buf);
	printk(KERN_INFO "Sizeof buf : %lu", strlen(buf));	
	filp_close(f,NULL);
	
	i = j = 0;
	tempchar = kmalloc(sizeof(char)*MaxList, GFP_KERNEL);
	if(tempchar == NULL){
		printk(KERN_ALERT "Error allocating size to buff.");
		return 0;
	}
	
	// tempchar = '\0';
	printk(KERN_ALERT "PHASE 12\n");
	
	while(buf[i] != '\0'){
		printk(KERN_ALERT "PHASE 0%d\n", i);
		if(buf[i] == '\n'){
			if(buff[j] == NULL){
				printk(KERN_ALERT "Error allocating size to buff.");
				return 0;
			}
			printk(KERN_ALERT "PHASE inside if %d=i ,j=%d\n", i,j);
			strcpy(buff[j], tempchar);
			tempchar = '\0';
			j++;
		}
		printk(KERN_ALERT "Before concatenation %d\n", i);
		// concat_(tempchar, buf[i]);
		while(*tempchar != '\0'){
			tempchar++;
		}
		*tempchar = buf[i];
		tempchar++;
		*tempchar = '\0';
		printk(KERN_ALERT "After concatenation %d\n", i);
		i++;
	}
	return 1;
}

/*
void concat_(char *s1, char s2){
	printk(KERN_ALERT "Starting in concatenation \n");
	while(*s1 != '\0'){
		printk(KERN_ALERT "Yes 1 \n");
		s1++;
		printk(KERN_ALERT "Yes 2 \n");
	}
	*s1=s2;
	printk(KERN_ALERT "Yes 3 \n");
	s1++;
	printk(KERN_ALERT "Yes 4 \n");
	*s1='\0';
	printk(KERN_ALERT "Yes 5 \n");
	return;
}
*/